# --*-- coding:utf-8 --*--
# @time: 10/27/25
# @Author: SQD_Folding
# @File: fullatom_refine.py
"""
Full-atom refinement from a CA-only model using PDBFixer + OpenMM.

Pipeline:
  1) Load CA-only PDB (refined_ca.pdb) and parse CA coords + residue names.
  2) Use PDBFixer to add missing heavy atoms and hydrogens consistent with Amber14 templates.
  3) Minimize in OpenMM (ff14SB + GBn2 implicit solvent) with SOFT restraints on CA to the input CA coords.
  4) Write minimized all-atom PDB.

Inputs (same directory as this script):
  - refined_ca.pdb (CA-only, residue names must reflect the intended sequence)

Outputs (same directory):
  - fixer_built_init.pdb          (full-atom generated by PDBFixer, before minimization)
  - allatom_refined.pdb           (minimized structure)
"""

import os
import sys
from typing import Tuple, List
import numpy as np

# OpenMM + PDBFixer
import openmm as mm
from openmm import unit
from openmm import app
from pdbfixer import PDBFixer


SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
IN_CA_PDB = os.path.join(SCRIPT_DIR, "refined_ca.pdb")

OUT_INIT_PDB = os.path.join(SCRIPT_DIR, "fixer_built_init.pdb")
OUT_MIN_PDB  = os.path.join(SCRIPT_DIR, "allatom_refined.pdb")


# -------------------------------
# Utilities
# -------------------------------

def read_ca_from_pdb_lines(path: str) -> np.ndarray:
    """Read CA xyz (Å) from a PDB (keeps file order)."""
    if not os.path.isfile(path):
        raise FileNotFoundError(path)
    out = []
    with open(path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            if not (line.startswith("ATOM") or line.startswith("HETATM")):
                continue
            if line[12:16].strip() != "CA":
                continue
            try:
                x = float(line[30:38]); y = float(line[38:46]); z = float(line[46:54])
            except Exception:
                continue
            out.append([x, y, z])
    if not out:
        raise RuntimeError(f"No CA atoms found in {path}")
    return np.asarray(out, dtype=float)


def extract_ca_indices(top: app.Topology) -> List[int]:
    """Return atom indices of all Cα in topology, in topology atom order."""
    return [a.index for a in top.atoms() if a.name == "CA"]


def write_pdb_with_positions(topology: app.Topology, positions_A: np.ndarray, out_path: str):
    """Write a PDB given topology and positions in Å."""
    with open(out_path, "w", encoding="utf-8") as f:
        serial = 1
        for chain in topology.chains():
            for res in chain.residues():
                for atom in res.atoms():
                    x, y, z = positions_A[atom.index]
                    elem = atom.element.symbol if atom.element is not None else "C"
                    f.write(
                        "ATOM  {serial:5d} {name:^4s} {res:>3s} {ch:1s}{rid:>4s}    "
                        "{x:8.3f}{y:8.3f}{z:8.3f}  1.00 20.00          {el:>2s}\n".format(
                            serial=serial,
                            name=atom.name[:4],
                            res=res.name[:3],
                            ch=(chain.id or "A")[:1],
                            rid=str(res.id) if res.id is not None else "1",
                            x=float(x), y=float(y), z=float(z),
                            el=elem[:2],
                        )
                    )
                    serial += 1
        f.write("END\n")


# -------------------------------
# Build full atom with PDBFixer
# -------------------------------

def build_fullatom_with_pdbfixer(ca_only_pdb: str) -> Tuple[app.Topology, np.ndarray]:
    """
    Use PDBFixer to add missing heavy atoms and H to a CA-only model.
    Returns (topology, positions_A).
    """
    fixer = PDBFixer(filename=ca_only_pdb)
    # We assume the CA-only PDB already contains the intended residues in order.
    # Steps: find missing atoms -> add them; then add hydrogens.
    fixer.findMissingResidues()
    # We do NOT add missing residues; the CA file should already include all residues.
    # fixer.missingResidues is info; leaving as is.

    fixer.findMissingAtoms()
    fixer.addMissingAtoms()
    fixer.addMissingHydrogens(pH=7.0)

    # Extract topology and positions (in nm)
    top = fixer.topology
    pos_nm = fixer.positions  # list of Vec3 in nm
    pos_A = unit.Quantity(pos_nm).value_in_unit(unit.angstrom)
    pos_arr = np.array([[p.x, p.y, p.z] for p in pos_A], dtype=float)

    # Save initial (for inspection)
    write_pdb_with_positions(top, pos_arr, OUT_INIT_PDB)
    return top, pos_arr


# -------------------------------
# Minimization with soft CA restraints
# -------------------------------

def minimize_with_soft_ca_restraints(
    top: app.Topology,
    init_positions_A: np.ndarray,
    ca_ref_A: np.ndarray,
    k_pos_kj_per_mol_nm2: float = 2000.0,
    n_steps_min: int = 6000,
    run_short_anneal: bool = False,
    platform_name: str = None,
) -> np.ndarray:
    """
    Minimize with ff14SB + GBn2 implicit solvent and soft CA positional restraints.
    Returns positions in Å (N,3).
    """
    ff = app.ForceField("amber14/protein.ff14SB.xml", "amber14/implicit/gbn2.xml")
    modeller = app.Modeller(top, unit.Quantity(init_positions_A, unit.angstrom))
    # Hydrogens were already added by PDBFixer; still safe to call addHydrogens (no-op)
    modeller.addHydrogens(ff, pH=7.0)

    system = ff.createSystem(
        modeller.topology,
        nonbondedMethod=app.NoCutoff,
        constraints=app.HBonds,
        removeCMMotion=True,
    )

    # Soft restraints on CA
    ca_idx = extract_ca_indices(modeller.topology)
    ref = ca_ref_A
    if len(ca_idx) != len(ref):
        # Align by truncation to shortest
        L = min(len(ca_idx), len(ref))
        ca_idx = ca_idx[:L]
        ref = ref[:L]

    ref_nm = (ref * unit.angstrom).value_in_unit(unit.nanometer)
    kforce = float(k_pos_kj_per_mol_nm2)

    restr = mm.CustomExternalForce("0.5*k*((x-x0)^2 + (y-y0)^2 + (z-z0)^2)")
    restr.addGlobalParameter("k", kforce)
    restr.addPerParticleParameter("x0")
    restr.addPerParticleParameter("y0")
    restr.addPerParticleParameter("z0")

    for i, atom_index in enumerate(ca_idx):
        x0, y0, z0 = ref_nm[i]
        restr.addParticle(int(atom_index), [float(x0), float(y0), float(z0)])

    system.addForce(restr)

    # Integrator/Simulation
    integrator = mm.LangevinMiddleIntegrator(300*unit.kelvin, 1.0/unit.picosecond, 0.002*unit.picosecond)
    platform = mm.Platform.getPlatformByName(platform_name) if platform_name else None
    sim = app.Simulation(modeller.topology, system, integrator, platform) if platform else app.Simulation(
        modeller.topology, system, integrator
    )
    sim.context.setPositions(modeller.positions)

    # Minimize
    sim.minimizeEnergy(maxIterations=int(n_steps_min))

    if run_short_anneal:
        def md(tempK: float, steps: int):
            sim.context.setVelocitiesToTemperature(tempK*unit.kelvin)
            sim.step(steps)
        md(50.0, 2000)
        md(300.0, 3000)
        md(50.0, 2000)
        sim.minimizeEnergy(maxIterations=2000)

    state = sim.context.getState(getPositions=True)
    pos_nm = state.getPositions(asNumpy=True)
    pos_A = pos_nm.value_in_unit(unit.angstrom)
    out = np.array([[p[0], p[1], p[2]] for p in pos_A], dtype=float)
    return out


# -------------------------------
# Main
# -------------------------------

def main():
    # 1) load CA reference (Å)
    ca_ref = read_ca_from_pdb_lines(IN_CA_PDB)
    print(f"[info] read {len(ca_ref)} CA atoms from '{os.path.basename(IN_CA_PDB)}'")

    # 2) build full-atom via PDBFixer (consistent templates)
    top, init_pos_A = build_fullatom_with_pdbfixer(IN_CA_PDB)
    print(f"[info] initial full-atom written to: {OUT_INIT_PDB}")

    # 3) minimize with soft CA restraints
    final_pos_A = minimize_with_soft_ca_restraints(
        top,
        init_positions_A=init_pos_A,
        ca_ref_A=ca_ref,
        k_pos_kj_per_mol_nm2=2000.0,
        n_steps_min=8000,
        run_short_anneal=False,
        platform_name=None,   # set to "CUDA" if you have OpenMM CUDA build
    )

    # 4) write minimized PDB
    write_pdb_with_positions(top, final_pos_A, OUT_MIN_PDB)
    print(f"[ok] wrote minimized PDB: {OUT_MIN_PDB}")


if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        print(f"[error] {e}")
        sys.exit(1)
